spring.application.name=emoblog-backend
server.error.include-message=always
server.error.include-path=never

# Security settings
security.jwt.secret=Jv8IfxQJqYw0x7k1nVYh5C3oVGT7F2m9n0GJcV5j1Yw=
security.jwt.expMinutes=60

# H2 Database settings
#spring.datasource.url=jdbc:h2:file:./db/demo
#spring.datasource.url=jdbc:h2:mem:mydb

# SQLite Database settings
spring.datasource.url=jdbc:sqlite:db/emoblog.db
spring.datasource.username=sa
spring.datasource.password=password

# JPA/Hibernate schema generation
# With a file-based H2 URL, Spring Boot defaults to 'none' and will not create tables.
# Enable auto DDL for dev so entities create/update tables on startup.
spring.jpa.database-platform=org.hibernate.community.dialect.SQLiteDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.datasource.hikari.connection-init-sql=PRAGMA foreign_keys=ON

# Base64 Secret
#
# 1. Generate a 256-bit value:
#    Unix/macOS: openssl rand -base64 32
#    Windows PowerShell: [Convert]::ToBase64String((1..32 | ForEach-Object { Get-Random
#   Minimum 0 -Maximum 256 }))
#
#   Kotlin snippet (e.g. in a unit test):
#   Base64.getEncoder().encodeToString(SecureRandom().generateSeed(32))
#
# 2. Paste the result into src/main/resources/application.properties:
#    security.jwt.secret=THE_GENERATED_VALUE
#    security.jwt.expMinutes=60
#    Avoid quotes or trailing whitespace. For non-local environments, inject via
#    environment variable SECURITY_JWT_SECRET or JVM arg -Dsecurity.jwt.secret=... so you
#    never commit secrets to git.
